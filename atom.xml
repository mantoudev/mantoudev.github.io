<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MantouDev</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mantoudev.com/"/>
  <updated>2018-11-26T14:48:52.441Z</updated>
  <id>http://mantoudev.com/</id>
  
  <author>
    <name>mantou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[大数据安全]基于Kerberos的大数据安全方案</title>
    <link href="http://mantoudev.com/2018/11/26/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8-%E5%9F%BA%E4%BA%8EKerberos%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%96%B9%E6%A1%88/"/>
    <id>http://mantoudev.com/2018/11/26/大数据安全-基于Kerberos的大数据安全方案/</id>
    <published>2018-11-26T13:39:40.000Z</published>
    <updated>2018-11-26T14:48:52.441Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>互联网从来就不是一个安全的地方。很多时候我们过分依赖防火墙来解决安全的问题，不幸的是，防火墙是假设“坏人”是来自外部的，而真正具有破坏性的攻击事件都是往往都是来自于内部的。</p><p>近几年，在<code>thehackernews</code>等网站上总会时不时的看到可以看到一些因为数据安全问题被大面积攻击、勒索的事件。在Hadoop1.0.0之前，Hadoop并不提供对安全的支持，默认集群内所有角色都是可靠的。用户访问时不需要进行任何验证,++导致++恶意用户很容易就可以伪装进入集群进行破坏。<br><a id="more"></a></p><p><img src="https://s1.ax1x.com/2018/11/03/i4WMu9.png" alt="不安全的Hadoop集群"></p><p>要保证Hadoop集群的安全，至少要做到2个A：<code>Authentication</code>(认证)，<code>Authorization</code>(授权)。常见的方案有：</p><ul><li><strong>Authentication</strong>：<br>MIT Kerberos, Azure AD, Kerby</li><li><strong>Authorization</strong>：<br>Apache Sentry(Cloudera), Apache Ranger(Hortonworks)</li></ul><p><img src="https://s1.ax2x.com/2018/10/30/5XI5Nu.png" alt="Hadoop Cluster Secure"></p><h5 id="Hadoop集群对Kerberos的支持"><a href="#Hadoop集群对Kerberos的支持" class="headerlink" title="Hadoop集群对Kerberos的支持"></a>Hadoop集群对Kerberos的支持</h5><p>2012年1.0.0版本正式发布后，Hadoop才增加了对Kerberos的支持, 使得集群中的节点是可信任的。</p><p>Kerberos可以将认证的密钥在集群部署时事先放到可靠的节点上。集群运行时，集群内的节点使用密钥得到认证，认证通过后的节点才能提供服务。企图冒充的节点由于没有事先得到的密钥信息，无法与集群内部的节点通信。这样就防止了恶意地使用或篡改Hadoop集群的问题，确保了Hadoop集群的可靠性、安全性。</p><h3 id="2-Kerberos介绍"><a href="#2-Kerberos介绍" class="headerlink" title="2.Kerberos介绍"></a>2.Kerberos介绍</h3><p>Kerberos是种网络身份验证协议,最初设计是用来保护雅典娜工程的网络服务器。Kerberos这个名字源于希腊神话，是一只三头犬的名字，它旨在通过使用密钥加密技术为Client/Server序提供强身份验证。可以用于防止窃听、防止重放攻击、保护数据完整性等场合，是一种应用对称密钥体制进行密钥管理的系统。Kerberos的扩展产品也使用公开密钥加密方法进行认证。</p><p>Kerberos目前最新版本是5，1~3版本只在MIT内部发行，因为使用DES加密，早期被美国出口管制局列为军需品禁止出口，直到瑞典皇家工学院实现了Kerberos版本4，KTH-KRB。后续也是这个团队实现了版本5: Heimdal，目前常见的Kerberos5实现之一。</p><p>本文中讨论的Kerberos5实现版本为MIT Kerberos，MIT保持的大约半年左右一次的更新速度，目前最新版本是2018-11-01发布的1.16.2版本。</p><h4 id="2-1-名词解释"><a href="#2-1-名词解释" class="headerlink" title="2.1 名词解释"></a>2.1 名词解释</h4><ul><li>AS（Authentication Server）：认证服务器</li><li>KDC（Key Distribution Center）：密钥分发中心</li><li>TGT（Ticket Granting Ticket）：票据授权票据，票据的票据</li><li>TGS（Ticket Granting Server）：票据授权服务器</li><li>SS（Service Server）：特定服务提供端</li><li>Principal：被认证的个体</li><li>Ticket：票据，客户端用来证明身份真实性。包含：用户名，IP，时间戳，有效期，会话秘钥。</li></ul><p>使用Kerberos时，一个客户端需要经过三个步骤来获取服务:</p><ol><li><code>认证</code>: 客户端向认证服务器发送一条报文，获取一个包含时间戳的TGT。  </li><li><code>授权</code>: 客户端使用TGT向TGS请求指定Service的Ticket。</li><li><code>服务请求</code>:   客户端向指定的Service出示服务Ticket鉴权通讯。</li></ol><p>Kerberos协议在网络通信协定中属于显示层。其通信流程简单地说，用户先用共享密钥从某认证服务器得到一个身份证明。随后，用户使用这个身份证明与SS通信，而不使用共享密钥。</p><h4 id="2-2-具体通信流程"><a href="#2-2-具体通信流程" class="headerlink" title="2.2 具体通信流程"></a>2.2 具体通信流程</h4><blockquote><p>①此流程使用了对称加密; ②此流程发生在某一个Kerberos领域中； ③小写字母c,d,e,g是客户端发出的消息，大写字母A,B,E,F,H是各个服务器发回的消息。</p></blockquote><p>首先，用户使用客户端上的程序进行登录：</p><ol><li>输入用户ID和密码到客户端（或使用keytab登录）。</li><li>客户端程序运行一个单向函数（大多数为Hash）把密码转换成密钥，这个就是客户端的“用户密钥”(user’s secret key)。</li></ol><h5 id="2-2-1-客户端认证（Kinit）"><a href="#2-2-1-客户端认证（Kinit）" class="headerlink" title="2.2.1 客户端认证（Kinit）"></a>2.2.1 客户端认证（Kinit）</h5><p>客户端(Client)从认证服务器(AS)获取票据的票据（TGT）。<br><img src="https://s1.ax2x.com/2018/10/30/5XIYmr.png" alt="客户端认证"></p><ol><li><p>Client向AS发送1条明文消息，申请基于该用户所应享有的服务，例如“用户Sunny想请求服务”（Sunny是用户ID）。（注意：用户不向AS发送“用户密钥”(user’s secret key)，也不发送密码）该AS能够从本地数据库中查询到该申请用户的密码，并通过相同途径转换成相同的“用户密钥”(user’s secret key)。</p></li><li><p>AS检查该用户ID是否在于本地数据库中，如果用户存在则返回2条消息：</p><ul><li>【消息A】：<strong>Client/TGS会话密钥(Client/TGS Session Key)</strong>（该Session Key用在将来Client与TGS的通信（会话）上），通过 <strong>用户密钥(user’s secret key)</strong> 进行加密。</li><li>【消息B】：<strong>票据授权票据(TGT)</strong>（TGT包括：消息A中的“Client/TGS会话密钥”(Client/TGS Session Key)，用户ID，用户网址，TGT有效期），通过<strong>TGS密钥(TGS’s secret key)</strong> 进行加密。</li></ul></li><li><p>一旦Client收到消息A和消息B，Client首先尝试用自己的“用户密钥”(user’s secret key)解密消息A，如果用户输入的密码与AS数据库中的密码不符，则不能成功解密消息A。输入正确的密码并通过随之生成的”user’s secret key”才能解密消息A，从而得到“Client/TGS会话密钥”(Client/TGS Session Key)。（注意：Client不能解密消息B，因为B是用TGS密钥(TGS’s secret key)加密的）。拥有了“Client/TGS会话密钥”(Client/TGS Session Key)，Client就足以通过TGS进行认证了。</p></li></ol><h5 id="2-2-2-服务授权"><a href="#2-2-2-服务授权" class="headerlink" title="2.2.2 服务授权"></a>2.2.2 服务授权</h5><blockquote><p>Client从TGS获取票据(client-to-server ticket)。</p></blockquote><p><img src="https://s1.ax2x.com/2018/10/30/5XIziR.png" alt="服务授权"></p><ol><li><p>当client需要申请特定服务时，其向TGS发送以下2条消息：</p><ul><li>【消息c】：即消息B的内容（TGS’s secret key加密后的TGT），和想获取的服务的服务ID（注意：不是用户ID）。</li><li>【消息d】：<strong>认证符(Authenticator)</strong>（Authenticator包括：用户ID，时间戳），通过<strong>Client/TGS会话密钥(Client/TGS Session Key)</strong>进行加密。</li></ul></li><li><p>收到消息c和消息d后，TGS首先检查KDC数据库中是否存在所需的服务，查找到之后，TGS用自己的“TGS密钥”(TGS’s secret key)解密消息c中的消息B（也就是TGT），从而得到之前生成的“Client/TGS会话密钥”(Client/TGS Session Key)。TGS再用这个Session Key解密消息d得到包含用户ID和时间戳的Authenticator，并对TGT和Authenticator进行验证，验证通过之后返回2条消息：</p><ul><li>【消息E】：<strong>client-server票据(client-to-server ticket)</strong>（该ticket包括：Client/SS会话密钥 (Client/Server Session Key），用户ID，用户网址，有效期），通过提供该服务的<strong>服务器密钥(service’s secret key)</strong> 进行加密。</li><li>【消息F】：<strong>Client/SS会话密钥( Client/Server Session Key)</strong> （该Session Key用在将来Client与Server Service的通信（会话）上），通过<strong>Client/TGS会话密钥(Client/TGS Session Key)</strong> 进行加密。</li></ul></li><li><p>Client收到这些消息后，用“Client/TGS会话密钥”(Client/TGS Session Key)解密消息F，得到“Client/SS会话密钥”(Client/Server Session Key)。（注意：Client不能解密消息E，因为E是用“服务器密钥”(service’s secret key)加密的）。</p></li></ol><h5 id="2-2-3-服务请求"><a href="#2-2-3-服务请求" class="headerlink" title="2.2.3 服务请求"></a>2.2.3 服务请求</h5><blockquote><p>Client从SS获取服务。</p></blockquote><ol><li>当获得“Client/SS会话密钥”(Client/Server Session Key)之后，Client就能够使用服务器提供的服务了。Client向指定服务器SS发出2条消息：<ul><li>【消息e】：即上一步中的消息E“client-server票据”(client-to-server ticket)，通过<strong>服务器密钥(service’s secret key)</strong> 进行加密</li><li>【消息g】：新的<strong>Authenticator</strong>（包括：用户ID，时间戳），通过<strong>Client/SS会话密钥(Client/Server Session Key)</strong> 进行加密</li></ul></li><li><p>SS用自己的密钥(service’s secret key)解密消息e从而得到TGS提供的Client/SS会话密钥(Client/Server Session Key)。再用这个会话密钥解密消息g得到Authenticator，（同TGS一样）对Ticket和Authenticator进行验证，验证通过则返回1条消息（确认函：确证身份真实，乐于提供服务）。</p><ul><li>【消息H】：<strong>新时间戳</strong>（新时间戳是：Client发送的时间戳加1，v5已经取消这一做法），通过<strong>Client/SS会话密钥(Client/Server Session Key)</strong> 进行加密。</li></ul></li><li><p>Client通过Client/SS会话密钥(Client/Server Session Key)解密消息H，得到新时间戳并验证其是否正确。验证通过的话则客户端可以信赖服务器，并向服务器（SS）发送服务请求。</p></li><li><p>服务器（SS）向客户端提供相应的服务。</p></li></ol><h3 id="3-Kerberos-HA架构"><a href="#3-Kerberos-HA架构" class="headerlink" title="3.Kerberos HA架构"></a>3.Kerberos HA架构</h3><p>Kerberos支持两种服务器在域内冗余方式：<code>Master/Slave</code>（MIT和Heimdal）和<code>Multimaster</code>结构（Windows Active Directory）。在生产环境中部署Kerberos时，最好使用一主(Master)多从(Slave)的架构，以确保Kerberos服务的高可用性。</p><p>Kerberos中每个KDC都包含数据库的副本。主KDC包含域（Realm）数据库的<strong>可写副本</strong>，它以固定的时间间隔复制到从KDC中。所有数据库更改（例如密码更改）都在主KDC上进行，当主KDC不可用时，从KDC提供Kerberos票据给服务授权，但不提供数据库管理。KDC需要一个Admin来进行日常的管理操作。</p><p>Kerberos的同步机制只复制主数据库的内容，但不传递配置文件，以下文件必须手动复制到每个Slave中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- krb5.conf</span><br><span class="line">- kdc.conf</span><br><span class="line">- kadm5.acl</span><br><span class="line">- master key stash file</span><br></pre></td></tr></table></figure></p><h4 id="3-1-HA方案"><a href="#3-1-HA方案" class="headerlink" title="3.1 HA方案"></a>3.1 HA方案</h4><p>目前单机房HA方案使用的较多的是Keepalived + Rsync 。Keepalived可以将多个无状态的单点通过虚拟IP(以下称为VIP)漂移的方式搭建成一个高可用服务。</p><p>首先，在Master KDC中创建数据库的dump文件(将当前的Kerberos和KADM5数据库转储为ASCII文件)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kdb5_util dump [-b7|-ov|-r13] [-verbose] [-mkey_convert] [-new_mkey_file mkey_file] [-rev] [-recurse] [filename [principals...]]</span><br></pre></td></tr></table></figure></p><p>然后使用Rsync将目录同步到Slave机器的对应目录中，<br>再导入KDC中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kdb5_util load [-b7|-ov|-r13] [-hash] [-verbose] [-update] filename [dbname]</span><br></pre></td></tr></table></figure></p><p>Hadoop所有请求通过请求内网域名，解析到Keepalived绑定的VIP的方式来使用KDC:<br><img src="https://s1.ax1x.com/2018/11/03/i4TRJI.png" alt="Kerberos HA"></p><h3 id="4-优化和展望"><a href="#4-优化和展望" class="headerlink" title="4. 优化和展望"></a>4. 优化和展望</h3><h4 id="4-1-优化"><a href="#4-1-优化" class="headerlink" title="4.1 优化"></a>4.1 优化</h4><h6 id="（1）用户（Principal）管理"><a href="#（1）用户（Principal）管理" class="headerlink" title="（1）用户（Principal）管理"></a>（1）用户（Principal）管理</h6><p>如果团队中已经有一套权限系统，要将现有的身份系统集成到Kerberos中会很困难。<br>随着业务的飞速增长，服务器规模越来越大，Kerberos Principal手动操作会越来越频繁，手动的增删改查维护会非常痛苦。需要在Kerberos管理系统中规范Principal申请、维护、删除、keytab生成流程。Principal申请和权限管理自动化。</p><h5 id="（2）数据同步优化"><a href="#（2）数据同步优化" class="headerlink" title="（2）数据同步优化"></a>（2）数据同步优化</h5><p>Kerberos数据同步可以将生成的数据记录同步写入到MySQL中，使用MySQL双主同步方式。在跨机房环境中，KDC数据使用Rsync工具进行增量同步。以A核心机房作为主机房，Rsync Server使用了Keepalived VIP的方式，当Kerberos主机宕机后，VIP漂移到另外一台主机器上，Rsync Client会以VIP所在的KDC主机器为Rsync Server进行数据同步，以保证KDC数据同步的高可用性。</p><h5 id="（3）运维"><a href="#（3）运维" class="headerlink" title="（3）运维"></a>（3）运维</h5><p>使用进程管理工具对Kerberos相关进程进行存活监控，当发现有进程异常退出时，邮件/微信/钉钉报警，主动再次拉起进程。</p><h4 id="4-2-展望"><a href="#4-2-展望" class="headerlink" title="4.2 展望"></a>4.2 展望</h4><p>部署过Kerberos的同学都知道，在Hadoop集群部署Kerberos实际是一项非常繁琐的工作。Kerberos本质上是一种协议或安全通道，对于大多数用户或普通用户来说，是有一定学习曲线的，是否有更好的实现能够对普通用户隐藏这些繁琐的细节。</p><p>阿里和Intel合作项目Hadoop Authentication Service (HAS) 据称目前已经应用到ApsaraDB for HBase2.0中:<br><img src="https://s1.ax1x.com/2018/11/03/i4H9jf.png" alt="HAS"></p><p>HAS方案使用Kerby替代MIT Kerberos服务，利用HAS插件式验证方式建立一套人们习惯的账户密码体系。</p><p>目前HAS在Apache Kerby项目<code>has-project</code>分支开发中，未来会作为Kerbby的新feature出现在下一次release中。</p><p>Apache Kerby作为Apache Directory的一个子项目，目前关注度并不高，让我们期待它在后续的发展吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1.背景&quot;&gt;&lt;/a&gt;1.背景&lt;/h3&gt;&lt;p&gt;互联网从来就不是一个安全的地方。很多时候我们过分依赖防火墙来解决安全的问题，不幸的是，防火墙是假设“坏人”是来自外部的，而真正具有破坏性的攻击事件都是往往都是来自于内部的。&lt;/p&gt;
&lt;p&gt;近几年，在&lt;code&gt;thehackernews&lt;/code&gt;等网站上总会时不时的看到可以看到一些因为数据安全问题被大面积攻击、勒索的事件。在Hadoop1.0.0之前，Hadoop并不提供对安全的支持，默认集群内所有角色都是可靠的。用户访问时不需要进行任何验证,++导致++恶意用户很容易就可以伪装进入集群进行破坏。&lt;br&gt;
    
    </summary>
    
      <category term="BigData, Auth" scheme="http://mantoudev.com/categories/BigData-Auth/"/>
    
    
      <category term="Kerberos, 大数据安全" scheme="http://mantoudev.com/tags/Kerberos-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
